---
phase: 06-containerized-openvpn-portal
plan: 2
type: execute
---

<objective>
Create Flask portal container structure and migrate web application code.

Purpose: Build the Flask web portal container that provides HTTPS interface for client management, moving from host-based to containerized deployment.
Output: portal/Dockerfile, portal/requirements.txt, and portal/app/ directory with Flask application code.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-containerized-openvpn-portal/DISCOVERY.md
@.planning/phases/06-containerized-openvpn-portal/06-01-SUMMARY.md
@install.sh

**Current state:**
- install.sh contains embedded Flask app code (currently deployed to host /root/openvpn-portal/)
- Flask app uses bcrypt for password auth, session management, client CRUD operations
- Portal serves on HTTPS with self-signed certificates

**Discovery findings:**
- Use python:3.11-slim base image
- Portal needs read-only access to OpenVPN PKI volume (/etc/openvpn/easy-rsa)
- Generate self-signed HTTPS cert on first run (like v1.0 pattern)
- Run Flask as non-root user (vpnuser UID 1000)
- Requirements: flask, bcrypt, pyopenssl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Portal Dockerfile and requirements.txt</name>
  <files>portal/Dockerfile, portal/requirements.txt</files>
  <action>
Create portal/requirements.txt with Flask dependencies:
- Flask==3.0.0
- bcrypt==4.1.2
- pyopenssl==23.3.0

Create portal/Dockerfile with:
- Base image: python:3.11-slim
- Install system dependencies: apt-get install -y openssl (clean up apt lists)
- WORKDIR /app
- COPY requirements.txt and RUN pip install --no-cache-dir -r requirements.txt
- COPY app/ /app/
- Create directories: mkdir -p /app/certs /app/data
- Create non-root user: useradd -m -u 1000 vpnuser && chown -R vpnuser:vpnuser /app
- USER vpnuser
- EXPOSE 443
- CMD ["python", "app.py"]

Keep Dockerfile simple. Don't add unnecessary packages.
  </action>
  <verify>
- portal/Dockerfile exists with python:3.11-slim base
- portal/requirements.txt exists with Flask, bcrypt, pyopenssl
- Dockerfile creates vpnuser and switches to non-root
- Dockerfile exposes port 443
- CMD runs app.py
  </verify>
  <done>Portal Dockerfile and requirements created with proper structure</done>
</task>

<task type="auto">
  <name>Task 2: Extract and restructure Flask app code</name>
  <files>portal/app/app.py, portal/app/templates/login.html, portal/app/templates/dashboard.html, portal/app/static/style.css</files>
  <action>
Extract Flask application code from install.sh (currently embedded as heredocs in setup_web_portal function) and create proper file structure:

1. Create portal/app/app.py with:
   - Flask app initialization
   - Load PORTAL_PASSWORD_HASH and SESSION_SECRET from environment variables
   - HTTPS setup using /app/certs/cert.pem and /app/certs/key.pem
   - Routes: / (redirect to login), /login (GET/POST), /dashboard (session-protected), /logout
   - API routes: /api/clients (GET list), /api/clients (POST create), /api/clients/<name> (DELETE)
   - File download: /download/<filename> (secure, session-protected)
   - Easy-RSA commands use /etc/openvpn/easy-rsa/ path (shared volume)
   - Client config generation logic (same as v1.0)
   - Server cert revocation and CRL update logic

2. Create portal/app/templates/login.html:
   - Simple login form (username hidden field "admin", password input, submit button)
   - Error message display
   - Basic CSS styling

3. Create portal/app/templates/dashboard.html:
   - Header with logout button
   - "Create Client" form (client name input, submit)
   - Client list table (name, created date, download button, delete button)
   - JavaScript for AJAX create/delete operations
   - Download link generation

4. Create portal/app/static/style.css:
   - Basic styling matching v1.0 portal appearance
   - Responsive layout
   - Button and form styles

Add HTTPS certificate generation logic to app.py startup:
- Check if /app/certs/cert.pem exists
- If not: Generate self-signed cert with openssl (valid 365 days)
- Use environment variable SERVER_IP for certificate CN

The app should work identically to v1.0 portal, just containerized.
  </action>
  <verify>
- portal/app/app.py exists with Flask routes and Easy-RSA integration
- portal/app/templates/login.html exists
- portal/app/templates/dashboard.html exists
- portal/app/static/style.css exists
- app.py loads environment variables (PORTAL_PASSWORD_HASH, SESSION_SECRET, SERVER_IP)
- app.py generates self-signed cert if missing
- Client management logic matches v1.0 functionality
  </verify>
  <done>Flask app code extracted from install.sh and restructured into portal/app/ directory</done>
</task>

<task type="auto">
  <name>Task 3: Test portal container builds</name>
  <files>None (verification only)</files>
  <action>
Build the portal container locally to verify it works:
1. Run: docker build --no-cache -t easyopenvpn-portal:test portal/
2. Verify build succeeds (warnings OK, errors NOT OK)
3. Inspect image: docker images | grep easyopenvpn-portal
4. Check non-root user: docker inspect easyopenvpn-portal:test | grep -A5 User

Don't run the container yet (Plan 3 handles orchestration).
Just verify the build process works and dependencies install correctly.
  </action>
  <verify>
- docker build command succeeds
- Image easyopenvpn-portal:test exists in docker images output
- docker inspect shows User is vpnuser (or UID 1000)
- No build errors in output
- Flask and dependencies installed successfully
  </verify>
  <done>Portal container builds successfully with Flask app and dependencies</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] portal/Dockerfile exists and follows python:3.11-slim pattern
- [ ] portal/requirements.txt contains Flask, bcrypt, pyopenssl
- [ ] portal/app/ directory structure created with app.py, templates/, static/
- [ ] docker build succeeds without errors
- [ ] Flask app code matches v1.0 functionality
</verification>

<success_criteria>
- All tasks completed
- Portal container structure created
- Flask app migrated from install.sh to portal/app/
- Container builds successfully
- Ready for integration with docker-compose.yml (Plan 3)
</success_criteria>

<output>
After completion, create `.planning/phases/06-containerized-openvpn-portal/06-02-SUMMARY.md`:

# Phase 6 Plan 2: Flask Portal Container Structure Summary

**[One-liner describing what was built]**

## Accomplishments

- [Key outcomes]

## Files Created/Modified

- `portal/Dockerfile` - Description
- `portal/requirements.txt` - Description
- `portal/app/app.py` - Description
- `portal/app/templates/*.html` - Description
- `portal/app/static/style.css` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 06-03-PLAN.md (Docker Compose orchestration and install.sh migration)
</output>
